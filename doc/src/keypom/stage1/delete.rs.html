<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `contract/src/stage1/delete.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>delete.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../keypom/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../keypom/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../keypom/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
</pre><pre class="rust"><code><span class="kw">use</span> <span class="ident">near_sdk::GasWeight</span>;

<span class="kw">use</span> <span class="kw">crate</span>::<span class="kw-2">*</span>;

<span class="attribute">#[<span class="ident">near_bindgen</span>]</span>
<span class="kw">impl</span> <span class="ident">Keypom</span> {
    <span class="comment">/*
        User can pass in a vector of public keys or a drop ID.
        If a drop ID is passed in, it will auto delete up to limit.
        If limit is not specified, auto assume 100 keys from the drop.
        All keys must be from the same drop ID.

        All keys must be unregistered (NFTs / FTs refunded) for the drop.
    */</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">delete_keys</span>(
        <span class="kw-2">&amp;mut</span> <span class="self">self</span>,
        <span class="ident">drop_id</span>: <span class="ident">DropId</span>,
        <span class="ident">public_keys</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">PublicKey</span><span class="op">&gt;</span><span class="op">&gt;</span>,
        <span class="ident">limit</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>,
        <span class="ident">delete_on_empty</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">bool</span><span class="op">&gt;</span>
    ) {
        <span class="comment">// Measure initial storage before doing any operations</span>
        <span class="kw">let</span> <span class="ident">initial_storage</span> <span class="op">=</span> <span class="ident">env::storage_usage</span>();

        <span class="comment">// get the drop object</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">drop</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">drop_for_id</span>.<span class="ident">remove</span>(<span class="kw-2">&amp;</span><span class="ident">drop_id</span>).<span class="ident">expect</span>(<span class="string">&quot;No drop found&quot;</span>);
        <span class="kw">let</span> <span class="ident">owner_id</span> <span class="op">=</span> <span class="ident">drop</span>.<span class="ident">owner_id</span>.<span class="ident">clone</span>();
        <span class="kw">let</span> <span class="ident">drop_type</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">drop</span>.<span class="ident">drop_type</span>;
        <span class="macro">require!</span>(
            <span class="ident">owner_id</span> <span class="op">==</span> <span class="ident">env::predecessor_account_id</span>(),
            <span class="string">&quot;only drop funder can delete keys&quot;</span>
        );

        <span class="comment">// Get the max claims per key. Default to 1 if not specified in the drop config.</span>
        <span class="kw">let</span> <span class="ident">uses_per_key</span> <span class="op">=</span> <span class="ident">drop</span>
            .<span class="ident">config</span>
            .<span class="ident">clone</span>()
            .<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">uses_per_key</span>)
            .<span class="ident">unwrap_or</span>(<span class="number">1</span>);

        <span class="comment">// Get optional costs</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ft_optional_costs_per_claim</span> <span class="op">=</span> <span class="number">0</span>;

        <span class="comment">// ensure that there are no FTs or NFTs left to be refunded</span>
        <span class="kw">match</span> <span class="ident">drop_type</span> {
            <span class="ident">DropType::NonFungibleToken</span>(<span class="kw">_</span>) =&gt; {
                <span class="macro">require!</span>(
                    <span class="ident">drop</span>.<span class="ident">registered_uses</span> <span class="op">==</span> <span class="number">0</span>,
                    <span class="string">&quot;NFTs must be refunded before keys are deleted&quot;</span>
                );
            }
            <span class="ident">DropType::FungibleToken</span>(<span class="ident">data</span>) =&gt; {
                <span class="macro">require!</span>(
                    <span class="ident">drop</span>.<span class="ident">registered_uses</span> <span class="op">==</span> <span class="number">0</span>,
                    <span class="string">&quot;FTs must be refunded before keys are deleted&quot;</span>
                );

                <span class="ident">ft_optional_costs_per_claim</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">ft_storage</span>.<span class="number">0</span>;
            }
            <span class="kw">_</span> =&gt; {}
        };

        <span class="comment">// Keep track of the total refund amount</span>
        <span class="kw">let</span> <span class="ident">total_refund_amount</span>;
        <span class="comment">// Default the keys to use to be the public keys or an empty vector. We&#39;ll populate it if no PKs are passed in.</span>
        <span class="kw">let</span> <span class="ident">keys_to_delete</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">total_allowance_left</span> <span class="op">=</span> <span class="number">0</span>;

        <span class="comment">// Get the total number of claims and none FCs across all keys being deleted</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">total_num_claims_refunded</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">total_num_none_fcs</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">total_fc_deposits</span> <span class="op">=</span> <span class="number">0</span>;
        <span class="comment">// If the user passed in public keys, loop through and remove them from the drop</span>
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">keys</span>) <span class="op">=</span> <span class="ident">public_keys</span> {
            <span class="comment">// Set the keys to delete equal to the keys passed in</span>
            <span class="ident">keys_to_delete</span> <span class="op">=</span> <span class="ident">keys</span>;

            <span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">keys_to_delete</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u128</span>;
            <span class="macro">require!</span>(
                <span class="ident">len</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">limit</span>.<span class="ident">unwrap_or</span>(<span class="number">100</span>) <span class="kw">as</span> <span class="ident">u128</span>,
                <span class="string">&quot;cannot delete more than 100 keys at a time&quot;</span>
            );
            <span class="macro">near_sdk::log!</span>(<span class="string">&quot;Removing {} keys from the drop&quot;</span>, <span class="ident">len</span>);

            <span class="comment">// Loop through and remove keys</span>
            <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">keys_to_delete</span> {
                <span class="comment">// Unlink key to drop ID</span>
                <span class="self">self</span>.<span class="ident">drop_id_for_pk</span>.<span class="ident">remove</span>(<span class="ident">key</span>);
                <span class="comment">// Attempt to remove the public key. panic if it didn&#39;t exist</span>
                <span class="kw">let</span> <span class="ident">key_info</span> <span class="op">=</span> <span class="ident">drop</span>.<span class="ident">pks</span>.<span class="ident">remove</span>(<span class="ident">key</span>).<span class="ident">expect</span>(<span class="string">&quot;public key must be in drop&quot;</span>);
                <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">k</span>) <span class="op">=</span> <span class="ident">key_info</span>.<span class="ident">pw_per_use</span> {
                    <span class="ident">k</span>.<span class="ident">clear</span>();
                }

                <span class="ident">total_num_claims_refunded</span> <span class="op">+</span><span class="op">=</span> <span class="ident">key_info</span>.<span class="ident">remaining_uses</span>;

                <span class="comment">// If the drop is FC, we need to loop through method_name data for the remaining number of</span>
                <span class="comment">// Claims and get the deposits left along with the total number of None FCs</span>
                <span class="kw">if</span> <span class="kw">let</span> <span class="ident">DropType::FunctionCall</span>(<span class="ident">data</span>) <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">drop</span>.<span class="ident">drop_type</span> {
                    <span class="kw">let</span> <span class="ident">num_fcs</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">methods</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span>;

                    <span class="comment">// If there&#39;s one FC specified and more than 1 claim per key, that FC is to be used</span>
                    <span class="comment">// For all the claims. In this case, we need to tally all the deposits for each claim.</span>
                    <span class="kw">if</span> <span class="ident">uses_per_key</span> <span class="op">&gt;</span> <span class="number">1</span> <span class="op">&amp;&amp;</span> <span class="ident">num_fcs</span> <span class="op">==</span> <span class="number">1</span> {
                        <span class="kw">let</span> <span class="ident">attached_deposit</span> <span class="op">=</span> <span class="ident">data</span>
                            .<span class="ident">methods</span>
                            .<span class="ident">iter</span>()
                            .<span class="ident">next</span>()
                            .<span class="ident">unwrap</span>()
                            .<span class="ident">clone</span>()
                            .<span class="ident">expect</span>(<span class="string">&quot;cannot have a single none function call&quot;</span>)
                            <span class="comment">// iterate through   all entries and sum the attached_deposit</span>
                            .<span class="ident">iter</span>()
                            .<span class="ident">fold</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">acc</span>, <span class="ident">x</span><span class="op">|</span> <span class="ident">acc</span> <span class="op">+</span> <span class="ident">x</span>.<span class="ident">attached_deposit</span>.<span class="number">0</span>);
                        <span class="macro">near_sdk::log!</span>(<span class="macro">format!</span>(
                            <span class="string">&quot;Total attached_deposits for all method data: {}&quot;</span>,
                            <span class="ident">attached_deposit</span>
                        )
                        .<span class="ident">as_str</span>());
                        <span class="ident">total_fc_deposits</span> <span class="op">+</span><span class="op">=</span> <span class="ident">key_info</span>.<span class="ident">remaining_uses</span> <span class="kw">as</span> <span class="ident">u128</span> <span class="op">*</span> <span class="ident">attached_deposit</span>;

                    <span class="comment">// In the case where either there&#39;s 1 claim per key or the number of FCs is not 1,</span>
                    <span class="comment">// We can simply loop through and manually get this data</span>
                    } <span class="kw">else</span> {
                        <span class="comment">// We need to loop through the remaining methods. This means we should skip and start at the</span>
                        <span class="comment">// MAX - keys left</span>
                        <span class="kw">let</span> <span class="ident">starting_index</span> <span class="op">=</span> (<span class="ident">uses_per_key</span> <span class="op">-</span> <span class="ident">key_info</span>.<span class="ident">remaining_uses</span>) <span class="kw">as</span> <span class="ident">usize</span>;
                        <span class="kw">for</span> <span class="ident">method_name</span> <span class="kw">in</span> <span class="ident">data</span>.<span class="ident">methods</span>.<span class="ident">iter</span>().<span class="ident">skip</span>(<span class="ident">starting_index</span>) {
                            <span class="ident">total_num_none_fcs</span> <span class="op">+</span><span class="op">=</span> <span class="ident">method_name</span>.<span class="ident">is_none</span>() <span class="kw">as</span> <span class="ident">u64</span>;

                            <span class="comment">// If the method is not None, we need to get the attached_deposit by looping through the method datas</span>
                            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">method_data</span>) <span class="op">=</span> <span class="ident">method_name</span> {
                                <span class="kw">let</span> <span class="ident">attached_deposit</span> <span class="op">=</span> <span class="ident">method_data</span>
                                    .<span class="ident">iter</span>()
                                    .<span class="ident">fold</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">acc</span>, <span class="ident">x</span><span class="op">|</span> <span class="ident">acc</span> <span class="op">+</span> <span class="ident">x</span>.<span class="ident">attached_deposit</span>.<span class="number">0</span>);
                                <span class="ident">total_fc_deposits</span> <span class="op">+</span><span class="op">=</span> <span class="ident">attached_deposit</span>;
                            }
                        }
                    }
                }

                <span class="comment">// Increment the allowance left by whatever is left on the key</span>
                <span class="ident">total_allowance_left</span> <span class="op">+</span><span class="op">=</span> <span class="ident">key_info</span>.<span class="ident">allowance</span>;
            }

            <span class="comment">// If the drop has no keys, remove it from the funder. Otherwise, insert it back with the updated keys.</span>
            <span class="kw">if</span> <span class="ident">drop</span>.<span class="ident">pks</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">0</span> <span class="op">&amp;&amp;</span> <span class="ident">delete_on_empty</span>.<span class="ident">unwrap_or</span>(<span class="bool-val">true</span>) {
                <span class="macro">near_sdk::log!</span>(<span class="string">&quot;Drop empty. Removing from funder. delete_on_empty: true&quot;</span>);
                <span class="self">self</span>.<span class="ident">internal_remove_drop_for_funder</span>(<span class="kw-2">&amp;</span><span class="ident">owner_id</span>, <span class="kw-2">&amp;</span><span class="ident">drop_id</span>);
            } <span class="kw">else</span> {
                <span class="macro">near_sdk::log!</span>(<span class="string">&quot;Drop non empty or delete on empty not set to true. Adding back. Len: {}. Delete on empty: {}&quot;</span>, <span class="ident">drop</span>.<span class="ident">pks</span>.<span class="ident">len</span>(), <span class="ident">delete_on_empty</span>.<span class="ident">unwrap_or</span>(<span class="bool-val">false</span>));
                <span class="self">self</span>.<span class="ident">drop_for_id</span>.<span class="ident">insert</span>(<span class="kw-2">&amp;</span><span class="ident">drop_id</span>, <span class="kw-2">&amp;</span><span class="ident">drop</span>);
            }

            <span class="comment">// Calculate the storage being freed. initial - final should be &gt;= 0 since final should be smaller than initial.</span>
            <span class="kw">let</span> <span class="ident">final_storage</span> <span class="op">=</span> <span class="ident">env::storage_usage</span>();
            <span class="kw">let</span> <span class="ident">total_storage_freed</span> <span class="op">=</span>
                <span class="ident">Balance::from</span>(<span class="ident">initial_storage</span> <span class="op">-</span> <span class="ident">final_storage</span>) <span class="op">*</span> <span class="ident">env::storage_byte_cost</span>();
            <span class="macro">near_sdk::log!</span>(
                <span class="string">&quot;Storage freed: {} bytes: {}&quot;</span>,
                <span class="ident">yocto_to_near</span>(<span class="ident">total_storage_freed</span>),
                <span class="ident">total_storage_freed</span>
            );

            <span class="comment">/*
                Required attached_deposit consists of:
                - TOTAL Storage freed
                - Total access key allowance for EACH key
                - Access key storage for EACH key
                - Balance for each key * (number of claims - claims with None for FC Data)

                Optional:
                - total FC deposits
                - FT storage registration cost for each key * claims (calculated in resolve storage calculation function)
            */</span>
            <span class="kw">let</span> <span class="ident">total_access_key_storage</span> <span class="op">=</span> <span class="ident">ACCESS_KEY_STORAGE</span> <span class="op">*</span> <span class="ident">len</span>;
            <span class="kw">let</span> <span class="ident">total_deposits</span> <span class="op">=</span>
                <span class="ident">drop</span>.<span class="ident">deposit_per_use</span> <span class="op">*</span> (<span class="ident">total_num_claims_refunded</span> <span class="op">-</span> <span class="ident">total_num_none_fcs</span>) <span class="kw">as</span> <span class="ident">u128</span>;
            <span class="kw">let</span> <span class="ident">total_ft_costs</span> <span class="op">=</span> <span class="ident">ft_optional_costs_per_claim</span> <span class="op">*</span> <span class="ident">total_num_claims_refunded</span> <span class="kw">as</span> <span class="ident">u128</span>;

            <span class="ident">total_refund_amount</span> <span class="op">=</span> <span class="ident">total_storage_freed</span>
                <span class="op">+</span> <span class="ident">total_allowance_left</span>
                <span class="op">+</span> <span class="ident">total_access_key_storage</span>
                <span class="op">+</span> <span class="ident">total_deposits</span>
                <span class="op">+</span> <span class="ident">total_fc_deposits</span>
                <span class="op">+</span> <span class="ident">total_ft_costs</span>;

            <span class="macro">near_sdk::log!</span>(
                <span class="string">&quot;Total refund: {}
                storage freed: {}
                allowance left: {}
                access key storage {}
                total deposits: {}
                total fc deposits: {}
                total ft costs: {}
                total num claims left: {}
                total num none FCs {}
                len: {}&quot;</span>,
                <span class="ident">yocto_to_near</span>(<span class="ident">total_refund_amount</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_storage_freed</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_allowance_left</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_access_key_storage</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_deposits</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_fc_deposits</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_ft_costs</span>),
                <span class="ident">total_num_claims_refunded</span>,
                <span class="ident">total_num_none_fcs</span>,
                <span class="ident">len</span>
            );
        } <span class="kw">else</span> {
            <span class="comment">// If no PKs were passed in, attempt to remove limit or 100 keys at a time</span>
            <span class="ident">keys_to_delete</span> <span class="op">=</span> <span class="ident">drop</span>.<span class="ident">pks</span>.<span class="ident">keys</span>().<span class="ident">take</span>(<span class="ident">limit</span>.<span class="ident">unwrap_or</span>(<span class="number">100</span>).<span class="ident">into</span>()).<span class="ident">collect</span>();

            <span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">keys_to_delete</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u128</span>;
            <span class="macro">near_sdk::log!</span>(<span class="string">&quot;Removing {} keys from the drop&quot;</span>, <span class="ident">len</span>);

            <span class="comment">// Loop through and remove keys</span>
            <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">keys_to_delete</span> {
                <span class="comment">// Unlink key to drop ID</span>
                <span class="self">self</span>.<span class="ident">drop_id_for_pk</span>.<span class="ident">remove</span>(<span class="ident">key</span>);
                <span class="comment">// Attempt to remove the public key. panic if it didn&#39;t exist</span>
                <span class="kw">let</span> <span class="ident">key_info</span> <span class="op">=</span> <span class="ident">drop</span>.<span class="ident">pks</span>.<span class="ident">remove</span>(<span class="ident">key</span>).<span class="ident">expect</span>(<span class="string">&quot;public key must be in drop&quot;</span>);
                <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">k</span>) <span class="op">=</span> <span class="ident">key_info</span>.<span class="ident">pw_per_use</span> {
                    <span class="ident">k</span>.<span class="ident">clear</span>();
                }
                <span class="ident">total_num_claims_refunded</span> <span class="op">+</span><span class="op">=</span> <span class="ident">key_info</span>.<span class="ident">remaining_uses</span>;

                <span class="comment">// If the drop is FC, we need to loop through method_name data for the remaining number of</span>
                <span class="comment">// Claims and get the deposits left along with the total number of None FCs</span>
                <span class="kw">if</span> <span class="kw">let</span> <span class="ident">DropType::FunctionCall</span>(<span class="ident">data</span>) <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">drop</span>.<span class="ident">drop_type</span> {
                    <span class="kw">let</span> <span class="ident">num_fcs</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">methods</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u64</span>;

                    <span class="comment">// If there&#39;s one FC specified and more than 1 claim per key, that FC is to be used</span>
                    <span class="comment">// For all the claims. In this case, we need to tally all the deposits for each claim.</span>
                    <span class="kw">if</span> <span class="ident">uses_per_key</span> <span class="op">&gt;</span> <span class="number">1</span> <span class="op">&amp;&amp;</span> <span class="ident">num_fcs</span> <span class="op">==</span> <span class="number">1</span> {
                        <span class="kw">let</span> <span class="ident">attached_deposit</span> <span class="op">=</span> <span class="ident">data</span>
                            .<span class="ident">methods</span>
                            .<span class="ident">iter</span>()
                            .<span class="ident">next</span>()
                            .<span class="ident">unwrap</span>()
                            .<span class="ident">clone</span>()
                            .<span class="ident">expect</span>(<span class="string">&quot;cannot have a single none function call&quot;</span>)
                            <span class="comment">// iterate through   all entries and sum the attached_deposit</span>
                            .<span class="ident">iter</span>()
                            .<span class="ident">fold</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">acc</span>, <span class="ident">x</span><span class="op">|</span> <span class="ident">acc</span> <span class="op">+</span> <span class="ident">x</span>.<span class="ident">attached_deposit</span>.<span class="number">0</span>);
                        <span class="macro">near_sdk::log!</span>(<span class="macro">format!</span>(
                            <span class="string">&quot;Total attached_deposits for all method data: {}&quot;</span>,
                            <span class="ident">attached_deposit</span>
                        )
                        .<span class="ident">as_str</span>());
                        <span class="ident">total_fc_deposits</span> <span class="op">+</span><span class="op">=</span> <span class="ident">key_info</span>.<span class="ident">remaining_uses</span> <span class="kw">as</span> <span class="ident">u128</span> <span class="op">*</span> <span class="ident">attached_deposit</span>;

                    <span class="comment">// In the case where either there&#39;s 1 claim per key or the number of FCs is not 1,</span>
                    <span class="comment">// We can simply loop through and manually get this data</span>
                    } <span class="kw">else</span> {
                        <span class="comment">// We need to loop through the remaining methods. This means we should skip and start at the</span>
                        <span class="comment">// MAX - keys left</span>
                        <span class="kw">let</span> <span class="ident">starting_index</span> <span class="op">=</span> (<span class="ident">uses_per_key</span> <span class="op">-</span> <span class="ident">key_info</span>.<span class="ident">remaining_uses</span>) <span class="kw">as</span> <span class="ident">usize</span>;
                        <span class="kw">for</span> <span class="ident">method_name</span> <span class="kw">in</span> <span class="ident">data</span>.<span class="ident">methods</span>.<span class="ident">iter</span>().<span class="ident">skip</span>(<span class="ident">starting_index</span>) {
                            <span class="ident">total_num_none_fcs</span> <span class="op">+</span><span class="op">=</span> <span class="ident">method_name</span>.<span class="ident">is_none</span>() <span class="kw">as</span> <span class="ident">u64</span>;
                            <span class="comment">// If the method is not None, we need to get the attached_deposit by looping through the method datas</span>
                            <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">method_data</span>) <span class="op">=</span> <span class="ident">method_name</span> {
                                <span class="kw">let</span> <span class="ident">attached_deposit</span> <span class="op">=</span> <span class="ident">method_data</span>
                                    .<span class="ident">iter</span>()
                                    .<span class="ident">fold</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">acc</span>, <span class="ident">x</span><span class="op">|</span> <span class="ident">acc</span> <span class="op">+</span> <span class="ident">x</span>.<span class="ident">attached_deposit</span>.<span class="number">0</span>);
                                <span class="ident">total_fc_deposits</span> <span class="op">+</span><span class="op">=</span> <span class="ident">attached_deposit</span>;
                            }
                        }
                    }
                }

                <span class="comment">// Increment the allowance left by whatever is left on the key</span>
                <span class="ident">total_allowance_left</span> <span class="op">+</span><span class="op">=</span> <span class="ident">key_info</span>.<span class="ident">allowance</span>;
            }

            <span class="comment">// If the drop has no keys, remove it from the funder. Otherwise, insert it back with the updated keys.</span>
            <span class="kw">if</span> <span class="ident">drop</span>.<span class="ident">pks</span>.<span class="ident">len</span>() <span class="op">==</span> <span class="number">0</span> <span class="op">&amp;&amp;</span> <span class="ident">delete_on_empty</span>.<span class="ident">unwrap_or</span>(<span class="bool-val">true</span>) {
                <span class="macro">near_sdk::log!</span>(<span class="string">&quot;Drop empty. Removing from funder. delete_on_empty: true&quot;</span>);
                <span class="self">self</span>.<span class="ident">internal_remove_drop_for_funder</span>(<span class="kw-2">&amp;</span><span class="ident">owner_id</span>, <span class="kw-2">&amp;</span><span class="ident">drop_id</span>);
            } <span class="kw">else</span> {
                <span class="macro">near_sdk::log!</span>(<span class="string">&quot;Drop non empty or delete on empty not set to true. Adding back. Len: {}. Delete on empty: {}&quot;</span>, <span class="ident">drop</span>.<span class="ident">pks</span>.<span class="ident">len</span>(), <span class="ident">delete_on_empty</span>.<span class="ident">unwrap_or</span>(<span class="bool-val">false</span>));
                <span class="self">self</span>.<span class="ident">drop_for_id</span>.<span class="ident">insert</span>(<span class="kw-2">&amp;</span><span class="ident">drop_id</span>, <span class="kw-2">&amp;</span><span class="ident">drop</span>);
            }

            <span class="comment">// Calculate the storage being freed. initial - final should be &gt;= 0 since final should be smaller than initial.</span>
            <span class="kw">let</span> <span class="ident">final_storage</span> <span class="op">=</span> <span class="ident">env::storage_usage</span>();
            <span class="kw">let</span> <span class="ident">total_storage_freed</span> <span class="op">=</span>
                <span class="ident">Balance::from</span>(<span class="ident">initial_storage</span> <span class="op">-</span> <span class="ident">final_storage</span>) <span class="op">*</span> <span class="ident">env::storage_byte_cost</span>();
            <span class="macro">near_sdk::log!</span>(
                <span class="string">&quot;Storage freed: {} bytes: {}&quot;</span>,
                <span class="ident">yocto_to_near</span>(<span class="ident">total_storage_freed</span>),
                <span class="ident">total_storage_freed</span>
            );

            <span class="comment">/*
                Required attached_deposit consists of:
                - TOTAL Storage freed
                - Total access key allowance for EACH key
                - Access key storage for EACH key
                - Balance for each key * (number of claims - claims with None for FC Data)

                Optional:
                - total FC deposits
                - FT storage registration cost for each key * claims (calculated in resolve storage calculation function)
            */</span>
            <span class="kw">let</span> <span class="ident">total_access_key_storage</span> <span class="op">=</span> <span class="ident">ACCESS_KEY_STORAGE</span> <span class="op">*</span> <span class="ident">len</span>;
            <span class="kw">let</span> <span class="ident">total_deposits</span> <span class="op">=</span>
                <span class="ident">drop</span>.<span class="ident">deposit_per_use</span> <span class="op">*</span> (<span class="ident">total_num_claims_refunded</span> <span class="op">-</span> <span class="ident">total_num_none_fcs</span>) <span class="kw">as</span> <span class="ident">u128</span>;
            <span class="kw">let</span> <span class="ident">total_ft_costs</span> <span class="op">=</span> <span class="ident">ft_optional_costs_per_claim</span> <span class="op">*</span> <span class="ident">total_num_claims_refunded</span> <span class="kw">as</span> <span class="ident">u128</span>;

            <span class="ident">total_refund_amount</span> <span class="op">=</span> <span class="ident">total_storage_freed</span>
                <span class="op">+</span> <span class="ident">total_allowance_left</span>
                <span class="op">+</span> <span class="ident">total_access_key_storage</span>
                <span class="op">+</span> <span class="ident">total_deposits</span>
                <span class="op">+</span> <span class="ident">total_fc_deposits</span>
                <span class="op">+</span> <span class="ident">total_ft_costs</span>;

            <span class="macro">near_sdk::log!</span>(
                <span class="string">&quot;Total refund: {}
                storage freed: {}
                allowance left: {}
                access key storage {}
                total deposits: {}
                total fc deposits: {}
                total ft costs: {}
                total num claims left: {}
                total num none FCs {}
                len: {}&quot;</span>,
                <span class="ident">yocto_to_near</span>(<span class="ident">total_refund_amount</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_storage_freed</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_allowance_left</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_access_key_storage</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_deposits</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_fc_deposits</span>),
                <span class="ident">yocto_to_near</span>(<span class="ident">total_ft_costs</span>),
                <span class="ident">total_num_claims_refunded</span>,
                <span class="ident">total_num_none_fcs</span>,
                <span class="ident">len</span>
            );
        }

        <span class="comment">// Refund the user</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cur_balance</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">user_balances</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">owner_id</span>).<span class="ident">unwrap_or</span>(<span class="number">0</span>);
        <span class="macro">near_sdk::log!</span>(
            <span class="string">&quot;Refunding user {} old balance: {}. Total allowance left: {}&quot;</span>,
            <span class="ident">yocto_to_near</span>(<span class="ident">total_refund_amount</span>),
            <span class="ident">yocto_to_near</span>(<span class="ident">cur_balance</span>),
            <span class="ident">yocto_to_near</span>(<span class="ident">total_allowance_left</span>)
        );
        <span class="ident">cur_balance</span> <span class="op">+</span><span class="op">=</span> <span class="ident">total_refund_amount</span>;
        <span class="self">self</span>.<span class="ident">user_balances</span>.<span class="ident">insert</span>(<span class="kw-2">&amp;</span><span class="ident">owner_id</span>, <span class="kw-2">&amp;</span><span class="ident">cur_balance</span>);

        <span class="comment">// Loop through and delete keys</span>
        <span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">keys_to_delete</span> {
            <span class="comment">// Create the batch promise</span>
            <span class="kw">let</span> <span class="ident">promise</span> <span class="op">=</span> <span class="ident">env::promise_batch_create</span>(<span class="kw-2">&amp;</span><span class="ident">env::current_account_id</span>());

            <span class="ident">env::promise_batch_action_delete_key</span>(<span class="ident">promise</span>, <span class="kw-2">&amp;</span><span class="ident">key</span>);

            <span class="ident">env::promise_return</span>(<span class="ident">promise</span>);
        }
    }

    <span class="comment">/*
        Refund NFTs or FTs for a drop. User can optionally pass in a number of assets to
        refund. If not, it will try to refund all assets.
    */</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">refund_assets</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">drop_id</span>: <span class="ident">DropId</span>, <span class="ident">assets_to_refund</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span>) {
        <span class="comment">// get the drop object</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">drop</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">drop_for_id</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">drop_id</span>).<span class="ident">expect</span>(<span class="string">&quot;No drop found&quot;</span>);
        <span class="kw">let</span> <span class="ident">owner_id</span> <span class="op">=</span> <span class="ident">drop</span>.<span class="ident">owner_id</span>.<span class="ident">clone</span>();
        <span class="macro">require!</span>(
            <span class="ident">owner_id</span> <span class="op">==</span> <span class="ident">env::predecessor_account_id</span>(),
            <span class="string">&quot;only drop funder can delete keys&quot;</span>
        );

        <span class="comment">// Get the number of claims registered for the drop.</span>
        <span class="kw">let</span> <span class="ident">claims_registered</span> <span class="op">=</span> <span class="ident">drop</span>.<span class="ident">registered_uses</span>;
        <span class="macro">require!</span>(<span class="ident">claims_registered</span> <span class="op">&gt;</span> <span class="number">0</span>, <span class="string">&quot;no claims left to unregister&quot;</span>);

        <span class="comment">// Get the claims to refund. If not specified, this is the number of claims currently registered.</span>
        <span class="kw">let</span> <span class="ident">num_to_refund</span> <span class="op">=</span> <span class="ident">assets_to_refund</span>.<span class="ident">unwrap_or</span>(<span class="ident">claims_registered</span>);
        <span class="macro">require!</span>(
            <span class="ident">num_to_refund</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">claims_registered</span>,
            <span class="string">&quot;can only refund less than or equal to the amount of keys registered&quot;</span>
        );

        <span class="comment">// Decrement the drop&#39;s keys registered temporarily. If the transfer is unsuccessful, revert in callback.</span>
        <span class="ident">drop</span>.<span class="ident">registered_uses</span> <span class="op">-</span><span class="op">=</span> <span class="ident">num_to_refund</span>;
        <span class="self">self</span>.<span class="ident">drop_for_id</span>.<span class="ident">insert</span>(<span class="kw-2">&amp;</span><span class="ident">drop_id</span>, <span class="kw-2">&amp;</span><span class="ident">drop</span>);

        <span class="kw">match</span> <span class="kw-2">&amp;mut</span> <span class="ident">drop</span>.<span class="ident">drop_type</span> {
            <span class="ident">DropType::NonFungibleToken</span>(<span class="ident">data</span>) =&gt; {
                <span class="comment">/*
                    NFTs need to be batched together. Loop through and transfer all NFTs.
                    Keys registered will be decremented and the token IDs will be removed
                    in the callback if everything is successful. If anything fails, the
                    keys registered will be added back in the callback for the drop.
                */</span>
                <span class="kw">let</span> <span class="ident">nft_batch_index</span> <span class="op">=</span> <span class="ident">env::promise_batch_create</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>.<span class="ident">contract_id</span>);
                <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">token_ids</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[];

                <span class="comment">// Loop through and pop / transfer all token IDs. If anything goes wrong, we send back all the token IDs, we popped and push them back in the callback.</span>
                <span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">num_to_refund</span> {
                    <span class="kw">let</span> <span class="ident">token_id</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">token_ids</span>.<span class="ident">pop</span>().<span class="ident">unwrap</span>();
                    <span class="ident">token_ids</span>.<span class="ident">push</span>(<span class="ident">token_id</span>.<span class="ident">clone</span>());
                    <span class="comment">// Send the NFTs back to the sender</span>
                    <span class="comment">// Call the function with the min GAS and then attach 1/5 of the unspent GAS to the call</span>
                    <span class="ident">env::promise_batch_action_function_call_weight</span>(
                        <span class="ident">nft_batch_index</span>,
                        <span class="string">&quot;nft_transfer&quot;</span>,
                        <span class="macro">json!</span>({ <span class="string">&quot;receiver_id&quot;</span>: <span class="ident">data</span>.<span class="ident">sender_id</span>, <span class="string">&quot;token_id&quot;</span>: <span class="ident">token_id</span>, <span class="string">&quot;memo&quot;</span>: <span class="string">&quot;Refund&quot;</span> }).<span class="ident">to_string</span>().<span class="ident">as_bytes</span>(),
                        <span class="number">1</span>,
                        <span class="ident">MIN_GAS_FOR_SIMPLE_NFT_TRANSFER</span>,
                        <span class="ident">GasWeight</span>(<span class="number">1</span>)
                    );
                }

                <span class="self">self</span>.<span class="ident">drop_for_id</span>.<span class="ident">insert</span>(<span class="kw-2">&amp;</span><span class="ident">drop_id</span>, <span class="kw-2">&amp;</span><span class="ident">drop</span>);

                <span class="comment">// Create the second batch promise to execute after the nft_batch_index batch is finished executing.</span>
                <span class="comment">// It will execute on the current account ID (this contract)</span>
                <span class="kw">let</span> <span class="ident">batch_ft_resolve_promise_id</span> <span class="op">=</span>
                    <span class="ident">env::promise_batch_then</span>(<span class="ident">nft_batch_index</span>, <span class="kw-2">&amp;</span><span class="ident">env::current_account_id</span>());

                <span class="comment">// Execute a function call as part of the resolved promise index created in promise_batch_then</span>
                <span class="comment">// Callback after all NFTs were refunded</span>
                <span class="comment">// Call the function with the min GAS and then attach 10/(10 + num_to_refund) of the unspent GAS to the call</span>
                <span class="ident">env::promise_batch_action_function_call_weight</span>(
                    <span class="ident">batch_ft_resolve_promise_id</span>,
                    <span class="string">&quot;nft_resolve_refund&quot;</span>,
                    <span class="macro">json!</span>({ <span class="string">&quot;drop_id&quot;</span>: <span class="ident">U128</span>(<span class="ident">drop_id</span>), <span class="string">&quot;token_ids&quot;</span>: <span class="ident">token_ids</span> })
                        .<span class="ident">to_string</span>()
                        .<span class="ident">as_bytes</span>(),
                    <span class="ident">NO_DEPOSIT</span>,
                    <span class="ident">MIN_GAS_FOR_RESOLVE_BATCH</span>,
                    <span class="ident">GasWeight</span>(<span class="number">10</span>),
                );
            }
            <span class="ident">DropType::FungibleToken</span>(<span class="ident">data</span>) =&gt; {
                <span class="comment">// All FTs can be refunded at once. Funder responsible for registering themselves</span>
                <span class="ident">ext_ft_contract::ext</span>(<span class="ident">data</span>.<span class="ident">contract_id</span>.<span class="ident">clone</span>())
                    <span class="comment">// Call ft transfer with 1 yoctoNEAR. 1/2 unspent GAS will be added on top</span>
                    .<span class="ident">with_attached_deposit</span>(<span class="number">1</span>)
                    .<span class="ident">ft_transfer</span>(
                        <span class="ident">data</span>.<span class="ident">sender_id</span>.<span class="ident">clone</span>(),
                        <span class="ident">U128</span>(<span class="ident">data</span>.<span class="ident">balance_per_use</span>.<span class="number">0</span> <span class="op">*</span> <span class="ident">num_to_refund</span> <span class="kw">as</span> <span class="ident">u128</span>),
                        <span class="prelude-val">None</span>,
                    )
                    <span class="comment">// We then resolve the promise and call nft_resolve_transfer on our own contract</span>
                    .<span class="ident">then</span>(
                        <span class="comment">// Call resolve refund with the min GAS and no attached_deposit. 1/2 unspent GAS will be added on top</span>
                        <span class="ident"><span class="self">Self</span>::ext</span>(<span class="ident">env::current_account_id</span>())
                            .<span class="ident">ft_resolve_refund</span>(<span class="ident">drop_id</span>, <span class="ident">num_to_refund</span>),
                    )
                    .<span class="ident">as_return</span>();
            }
            <span class="kw">_</span> =&gt; <span class="ident">env::panic_str</span>(<span class="string">&quot;can only refund assets for FT and NFT drops&quot;</span>),
        };
    }
}
</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="keypom" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0 (fe5b13d68 2022-05-18)" ></div>
</body></html>